# 游戏话题继续功能测试指南

## 测试目标

验证服务器重启后，游戏能够从中断处继续原有话题，而不是开始新话题。

## 测试场景

### 场景1：对话阶段中断恢复
1. **前置条件**：游戏正在进行法庭辩论阶段
2. **中断时机**：参与者已发言几次，但未完成所有发言
3. **预期结果**：恢复后继续原话题，从中断处继续发言

### 场景2：投票前中断恢复  
1. **前置条件**：对话刚好结束，准备进入投票
2. **中断时机**：所有发言完成，但投票未开始
3. **预期结果**：恢复后直接进入投票阶段，不重新开始新话题

### 场景3：轮次准备阶段中断
1. **前置条件**：轮次已创建但话题未确定
2. **中断时机**：轮次处于preparing状态
3. **预期结果**：恢复后设置新话题并开始对话

## 测试步骤

### 步骤1：启动游戏
```bash
cd backend
python main.py
```

### 步骤2：创建测试游戏
1. 前端创建新游戏（4个参与者）
2. 开始游戏，等待对话开始
3. 记录当前话题和已发言次数

### 步骤3：模拟中断
1. 在对话进行中（例如发言2-3次后）强制停止服务器
2. 或者在对话即将结束时停止服务器

### 步骤4：重启恢复
```bash
python main.py
```

### 步骤5：验证结果
检查启动日志中的恢复信息：
```
🔄 检查是否有需要恢复的游戏...
🎮 发现 1 个中断的游戏，开始恢复...
游戏 1 第1轮 状态: chatting, 阶段: chatting
游戏 1 继续第1轮对话阶段
恢复轮次 1 (ID: 1)，游戏 1，话题: [原话题名称]
轮次 1 已有 3 条发言，总需 8 条发言
轮次 1 从第 4 条发言继续
```

前端应显示：
```
⚖️ 继续中断的法庭审判从中断处恢复！辩论焦点：[原话题名称]
```

## 验证要点

### ✅ 成功标志
- [ ] 前端显示"继续中断的法庭审判从中断处恢复"
- [ ] 话题与中断前完全一致
- [ ] 发言序号从中断处继续（不重复）
- [ ] 参与者发言顺序保持一致
- [ ] 发言总数符合预期（participants × 2）

### ❌ 失败标志
- [ ] 显示"紧急法庭审判开始"（说明重新开始）
- [ ] 话题与中断前不同
- [ ] 发言序号从1重新开始
- [ ] 重复之前的发言内容

## 调试信息

### 关键日志
```bash
# 恢复阶段检测
游戏 X 第Y轮 状态: chatting, 阶段: chatting

# 话题检查
恢复轮次 Y (ID: Z)，游戏 X，话题: [话题名称]

# 发言计数
轮次 Y 已有 N 条发言，总需 M 条发言

# 继续策略
轮次 Y 从第 N+1 条发言继续
# 或
轮次 Y 辩论已完成，直接进入投票阶段
```

### 数据库检查
```sql
-- 检查轮次状态
SELECT id, game_id, round_number, topic, status, current_phase FROM rounds;

-- 检查发言记录
SELECT round_id, participant_id, sequence_number, message_type FROM messages 
WHERE round_id = [round_id] ORDER BY sequence_number;
```

## 常见问题排查

### Q: 恢复后重新开始了新话题
**排查步骤:**
1. 检查`current_phase`是否为"chatting"
2. 确认`resume_chat_round`方法是否被调用
3. 检查轮次记录中的`topic`字段

### Q: 发言序号重复或跳跃
**排查步骤:**
1. 确认`existing_messages`计数正确
2. 检查数据库中消息的`sequence_number`
3. 验证发言循环的起始值

### Q: 前端显示异常
**排查步骤:**
1. 检查WebSocket消息中的`is_resume`标志
2. 确认前端消息处理逻辑
3. 查看浏览器开发者工具的WebSocket消息

---

**注意**: 测试时建议使用较少的参与者（2-3个）以便更容易观察和验证结果。 